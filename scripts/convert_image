#! /usr/bin/python

from collections import namedtuple
import re
import sys

try:
	from PIL import Image
except ImportError:
	raise """\
		Pillow is required for this script to process images.
		Download from python-pillow.org or use your package manager
		to install it.
		"""




def load_image(file_name):
	return Image.open(file_name).convert('1')


ImageBytes = namedtuple('ImageBytes', ['width', 'height', 'data'])


def image_to_bytes(image):

	b_width, b_height = image.size
	b_width = (b_width + 7) // 8
	b = bytearray(b_width * b_height)
	
	for y in range(image.size[1]):
		for x in range(image.size[0]):
			if(image.getpixel((x, y)) == 0):
				b[y * b_width + x // 8] |= 1 << (7 - (x % 8))
	
	if b_width * b_height != len(b):
		raise "Bad width or height... this shouldn't happen"
	
	return ImageBytes(b_width, b_height, b)


def make_c_identifier_part(data_name):
	data_name = re.split(r'[\\/]', data_name)[-1] # get just the file name
	data_name = re.split(r'[.]', data_name)[0] # remove extension
	data_name = re.sub(r'[^a-zA-Z0-9]', '_', data_name) # replace non-alphanumeric chars
	data_name = re.sub(r'_+', '_', data_name) # remove excess underscores
	data_name = re.sub(r'_$|^_', '', data_name) # remove leading & trailing underscores
	data_name = data_name.upper()
	return data_name


def bytes_to_c_source(image_bytes, image_name):

	bytes_literal = ''
	for b in image_bytes.data:
		bytes_literal += r'\x' + hex(b)[2:]
	
	c_source = """\
	// This file is automatically generated by {prog_name}.
	// Images are stored row-first, with each byte containing 8 pixels.
	// Width of each line is given in bytes, height is given in lines.
	// Note that this format means images are always a multiple of 8
	// pixels wide.
	#ifndef DISP_IMG_{image_name}_FILE
	#define DISP_IMG_{image_name}_FILE
	#define DISP_IMG_{image_name}_WIDTH {image_bytes.width}
	#define DISP_IMG_{image_name}_HEIGHT {image_bytes.height}
	#define DISP_IMG_{image_name}_DATA "{bytes_literal}"
	#endif
	""".format(
		prog_name = re.split(r'[\\/]', sys.argv[0])[-1],
		image_name = image_name,
		image_bytes = image_bytes,
		bytes_literal = bytes_literal
	)
	
	return c_source



if __name__ == '__main__':
	
	import argparse
	
	parser = argparse.ArgumentParser(description = 'Convert images to C code for monochrome display')
	parser.add_argument('input_file', metavar = 'INPUT_FILE')
	parser.add_argument('-o', '--output-file', metavar = 'OUTPUT_FILE')
	parser.add_argument('-n', '--name', metavar = 'NAME')
	
	args = parser.parse_args()
		
	
	data_image = load_image(args.input_file)
	data_bytes = image_to_bytes(data_image)
	
	data_name = make_c_identifier_part(args.name or args.input_file)
	
	data_c_source = bytes_to_c_source(data_bytes, data_name)
	
	if args.output_file:
		with open(args.output_file, 'w') as file:
			file.write(data_c_source)
	else:
		print(data_c_source)
